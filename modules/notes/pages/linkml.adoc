= LinkML

== Purpose

LinkML is a flexible, versatile schema modeling language which can be used to represent a variety of kinds of models, including logical schemas, conceptual models or ontologies, taxonomies and controlled vocabularies.

Given the expressiveness of the metamodel, it is even possible to have a single LinkML schema represent multiple of these kinds of models. For example, a class definition could be regarded to represent some entity from the domain ontologically, as well as taxonomically, provided that the LinkML class definition expresses the necessary information needed to achieve this.

However, such a polyglot role for the LinkML schema comes with some challenges:

* LinkML was designed primarily for the purpose of data modeling, so its semantics and syntax are clearly most suited for that (<<LINKML-FAQ-ONT>>).
* Having one schema represent several kinds of models can cause confusion or, worse, actual limitations.
** LinkML cannot be expected to have the expressiveness of dedicated modeling languages geared towards a specific goal.
** Some constructs have the same name but different meanings in different kinds of models.


For these reasons, we shall use LinkML exclusively for the purpose it was designed for: modeling data.

See <<_why_not_vocabulary_modeling>> for a deeper and more concrete dive into this matter.


[caption=Decision]
IMPORTANT: We use LinkML solely to author schemas which represent a data model.

== Schema Modeling

It might be useful to say a few things about what it is we mean by _schema_ and _data model_.

[[dfn-data-model]]data model:: Model of data in which the expected shape of the data is expressed to enable validation and parsing by software.

[[dfn-schema]]schema:: A machine-readable, formal description representing a data model.

The word "shape" might ring a bell to those familiar with the W3C technology stack, in particular making one think of the Shapes Constraint Language (SHACL). This is deliberate on my part, since it is a helpful association, because LinkML and SHACL are both schema modeling languages with a similar purpose and plenty of overlap in semantics.

For example, class definition in LinkML schemas are basically the equivalence of class-targeting node shapes in SHACL. Furthermore, specifying cardinality constraints using LinkML meta slots like `required` and `maximum_cardinality`  follow the exact same semantics as the SHACL cardinality constraint components do.

To hammer this point home beyond doubt: LinkML classes do not represent ontological definitions of entities from the domain, but shapes which express expectation with regard to what the data is supposed to look like. Again, LinkML is a data modeling language, and such models are about structure, constraints and syntactical correctness, not about expressing the semantics of the domain.

However, LinkML does support adding semantics to your data model. After all, it is a _Linked Data modeling language_ for a reason. In particular, let's look at URI mappings.

Using meta slots such as `class_uri` and `slot_uri`, URIs referring to some definition from an ontology or vocabulary can be provided to express the meaning of the class for which the LinkML schema describes the expected shape.

WARNING: Do not misunderstand a specified `class_uri` to identify the class definition in LinkML itself. Instead, it identifies the class from some vocabulary or ontology for which this class definition describes the expected shape (structural and other types of constraints).

A comparison to SHACL can once again be helpful here. In SHACL, shapes can target resources for which they describe constraints. One commonly used construct is `sh:targetClass`, which targets a class from a vocabulary or ontology such that all instances of that class must conform to the node shape. In LinkML, using `class_uri` achieves the exact same goal.

CAUTION: When Linked Data URIs are necessary -- for example when generating Semantic Web models or working with RDF instance data -- and no URI mapping is specified for some element, LinkML will generate a URI for it based on the default prefix and local element name.

== Why Not Vocabulary Modeling

Let's take a closer look at why LinkML is not particularly suited for modeling a vocabulary.

First off, for obvious matters of expressiveness we shall immediately give up on the ambition of generating any serious OWL ontology from a LinkML schema. The inference semantics and highly expressive language semantics of OWL simply do not fit well into a LinkML schema (<<LINKML-FAQ-ONT>>).

Realistically, I will focus my efforts on representing a simple vocabulary with the expressivenss of RDFS. As you shall see, even this turns out to be a hard fit.

One reason for why this is hard, is because both RDF and RDFS do not support compound structures such as object-oriented classes. In other words: every resource you define is defined globally,; there is no notion of ownership or encapsulation as is the case with object-oriented modeling.

Mapping a class-bound attribute to a RDF property is complicated for another reason: a difference in semantics. RDFS operates under entailment (or inference) semantics, whereas data modeling operates under validation semantics. This means mapping a class attribute to a property and the class to the property's domain does not always yield the desired result.

.Inference vs validation semantics
====
Suppose we have the following class definition in LinkML:

[source,yaml]
....
Person:
  attributes:
    name:
      range: string
....

Let's naively go for the most straightforward mapping to RDFS:

[source,turtle]
....
:Person a rdfs:Class .

:name a rdf:Property ;
    rdfs:domain :Person ;
    rdfs:range xsd:string .
....

There's a couple of issues with this:

* If some other class has an attribute called `name`, do we mean the same? And even if you did: how do you map both classes to the domain properly?
* Due to RDFS's inference semantics this model does not express the same information. In the LinkML schema we are expressing that an instance of the class `Person`




====













[bibliography]
== References

* [[[LINKML-FAQ-ONT]]] https://linkml.io/linkml/faq/modeling.html#can-i-use-linkml-to-develop-ontologies